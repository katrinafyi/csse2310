!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Card	deck.h	/^typedef struct Card {$/;"	s
Card	deck.h	/^} Card;$/;"	t	typeref:struct:Card
DEBUG_PRINT	util.h	28;"	d
DEBUG_PRINTF	util.h	29;"	d
DECK_H	deck.h	2;"	d
Deck	deck.h	/^typedef struct Deck {$/;"	s
Deck	deck.h	/^} Deck;$/;"	t	typeref:struct:Deck
EXITCODES_H	exitCodes.h	2;"	d
GAMESTATE_H	gameState.h	2;"	d
GameState	gameState.h	/^typedef struct GameState {$/;"	s
GameState	gameState.h	/^} GameState;$/;"	t	typeref:struct:GameState
HUBSTATE_H	hubState.h	2;"	d
H_DECK_ERROR	exitCodes.h	/^    H_DECK_ERROR = 3,$/;"	e	enum:HubExitCode
H_DECK_SHORT	exitCodes.h	/^    H_DECK_SHORT = 4,$/;"	e	enum:HubExitCode
H_INCORRECT_ARGS	exitCodes.h	/^    H_INCORRECT_ARGS = 1,$/;"	e	enum:HubExitCode
H_INCORRECT_THRESHOLD	exitCodes.h	/^    H_INCORRECT_THRESHOLD = 2,$/;"	e	enum:HubExitCode
H_INVALID_CARD	exitCodes.h	/^    H_INVALID_CARD = 8,$/;"	e	enum:HubExitCode
H_INVALID_MESSAGE	exitCodes.h	/^    H_INVALID_MESSAGE = 7,$/;"	e	enum:HubExitCode
H_NORMAL	exitCodes.h	/^    H_NORMAL = 0,$/;"	e	enum:HubExitCode
H_PLAYER_EOF	exitCodes.h	/^    H_PLAYER_EOF = 6,$/;"	e	enum:HubExitCode
H_PLAYER_ERROR	exitCodes.h	/^    H_PLAYER_ERROR = 5,$/;"	e	enum:HubExitCode
H_SIGNAL	exitCodes.h	/^    H_SIGNAL = 9,$/;"	e	enum:HubExitCode
HubExitCode	exitCodes.h	/^typedef enum HubExitCode {$/;"	g
HubExitCode	exitCodes.h	/^} HubExitCode;$/;"	t	typeref:enum:HubExitCode
HubState	hubState.h	/^typedef struct HubState {$/;"	s
HubState	hubState.h	/^} HubState;$/;"	t	typeref:struct:HubState
INSTANT_SEGFAULT	util.h	12;"	d
LINE_BUFFER	util.c	9;"	d	file:
MESSAGES_H	messages.h	2;"	d
MSG_GAME_OVER	messages.h	/^            MSG_GAME_OVER, MSG_PLAY_CARD, MSG_NULL$/;"	e	enum:MessageType
MSG_HAND	messages.h	/^    MSG_HAND, MSG_NEW_ROUND, MSG_PLAYED_CARD,$/;"	e	enum:MessageType
MSG_NEW_ROUND	messages.h	/^    MSG_HAND, MSG_NEW_ROUND, MSG_PLAYED_CARD,$/;"	e	enum:MessageType
MSG_NULL	messages.h	/^            MSG_GAME_OVER, MSG_PLAY_CARD, MSG_NULL$/;"	e	enum:MessageType
MSG_PLAYED_CARD	messages.h	/^    MSG_HAND, MSG_NEW_ROUND, MSG_PLAYED_CARD,$/;"	e	enum:MessageType
MSG_PLAY_CARD	messages.h	/^            MSG_GAME_OVER, MSG_PLAY_CARD, MSG_NULL$/;"	e	enum:MessageType
MS_EOF	messages.h	/^    MS_OK, MS_EOF, MS_INVALID$/;"	e	enum:MessageStatus
MS_INVALID	messages.h	/^    MS_OK, MS_EOF, MS_INVALID$/;"	e	enum:MessageStatus
MS_OK	messages.h	/^    MS_OK, MS_EOF, MS_INVALID$/;"	e	enum:MessageStatus
Message	messages.h	/^typedef struct Message {$/;"	s
Message	messages.h	/^} Message;$/;"	t	typeref:struct:Message
MessageData	messages.h	/^typedef union MessageData {$/;"	u
MessageData	messages.h	/^} MessageData;$/;"	t	typeref:union:MessageData
MessageStatus	messages.h	/^typedef enum MessageStatus {$/;"	g
MessageStatus	messages.h	/^} MessageStatus;$/;"	t	typeref:enum:MessageStatus
MessageType	messages.h	/^typedef enum MessageType {$/;"	g
MessageType	messages.h	/^} MessageType;$/;"	t	typeref:enum:MessageType
NULL_CARD	deck.h	6;"	d
NUM_MESSAGE_TYPES	messages.h	10;"	d
PID_CHAR	util.h	16;"	d
PLAYERSTATE_H	playerState.h	2;"	d
P_HUB_EOF	exitCodes.h	/^    P_HUB_EOF = 7,$/;"	e	enum:PlayerExitCode
P_INCORRECT_ARGS	exitCodes.h	/^    P_INCORRECT_ARGS = 1,$/;"	e	enum:PlayerExitCode
P_INCORRECT_HAND	exitCodes.h	/^    P_INCORRECT_HAND = 5,$/;"	e	enum:PlayerExitCode
P_INCORRECT_PLAYERS	exitCodes.h	/^    P_INCORRECT_PLAYERS = 2,$/;"	e	enum:PlayerExitCode
P_INCORRECT_POSITION	exitCodes.h	/^    P_INCORRECT_POSITION = 3,$/;"	e	enum:PlayerExitCode
P_INCORRECT_THRESHOLD	exitCodes.h	/^    P_INCORRECT_THRESHOLD = 4,$/;"	e	enum:PlayerExitCode
P_INVALID_MESSAGE	exitCodes.h	/^    P_INVALID_MESSAGE = 6,$/;"	e	enum:PlayerExitCode
P_NORMAL	exitCodes.h	/^    P_NORMAL = 0,$/;"	e	enum:PlayerExitCode
PipePair	hubState.h	/^typedef struct PipePair {$/;"	s
PipePair	hubState.h	/^} PipePair;$/;"	t	typeref:struct:PipePair
PlayedTuple	messages.h	/^typedef struct PlayedTuple {$/;"	s
PlayedTuple	messages.h	/^} PlayedTuple;$/;"	t	typeref:struct:PlayedTuple
PlayerExitCode	exitCodes.h	/^typedef enum PlayerExitCode {$/;"	g
PlayerExitCode	exitCodes.h	/^} PlayerExitCode;$/;"	t	typeref:enum:PlayerExitCode
PlayerState	playerState.h	/^typedef struct PlayerState {$/;"	s
PlayerState	playerState.h	/^} PlayerState;$/;"	t	typeref:struct:PlayerState
STRATEGY_H	strategy.h	2;"	d
TERM_GREY	util.h	19;"	d
TERM_RED	util.h	20;"	d
TERM_RESET	util.h	21;"	d
TERM_REVERSE	util.h	22;"	d
UTIL_H	util.h	2;"	d
broadcast_message	hub.c	/^bool broadcast_message(HubState* hubState, Message message, int exclude) {$/;"	f
card	messages.h	/^    Card card; \/\/ for PLAY$/;"	m	union:MessageData
card	messages.h	/^    Card card;$/;"	m	struct:PlayedTuple
cards	deck.h	/^    Card* cards;$/;"	m	struct:Deck
cards_equal	deck.c	/^bool cards_equal(Card card1, Card card2) {$/;"	f
currPlayer	gameState.h	/^    int currPlayer;$/;"	m	struct:GameState
data	messages.h	/^    MessageData data; \/\/ data is undefined if type has no extra data!$/;"	m	struct:Message
deck_best_card	deck.c	/^int deck_best_card(Deck* deck, char suit, bool high) {$/;"	f
deck_clear	deck.c	/^void deck_clear(Deck* deck) {$/;"	f
deck_destroy	deck.c	/^void deck_destroy(Deck* deck) {$/;"	f
deck_index_of	deck.c	/^int deck_index_of(Deck* deck, Card card) {$/;"	f
deck_init_empty	deck.c	/^void deck_init_empty(Deck* deck, int numCards) {$/;"	f
deck_init_file	deck.c	/^bool deck_init_file(Deck* deck, char* deckFile) {$/;"	f
deck_is_empty	deck.c	/^bool deck_is_empty(Deck* deck) {$/;"	f
deck_is_full	deck.c	/^bool deck_is_full(Deck* deck) {$/;"	f
deck_remove_card	deck.c	/^void deck_remove_card(Deck* deck, Card card) {$/;"	f
deck_search	deck.c	/^int deck_search(Deck* hand, char* order, bool high) {$/;"	f
diamondsWon	gameState.h	/^    int* diamondsWon;$/;"	m	struct:GameState
do_load_deck	deck.c	/^bool do_load_deck(Deck* deck, FILE* file) {$/;"	f
exec_child	hub.c	/^void exec_child(int fdStdin, int fdStdout, char* name, char** argv) {$/;"	f
exec_hub_loop	hub.c	/^HubExitCode exec_hub_loop(HubState* hubState) {$/;"	f
exec_hub_main	hub.c	/^HubExitCode exec_hub_main(int argc, char** argv, HubState* hubState,$/;"	f
exec_player_loop	player.c	/^PlayerExitCode exec_player_loop(PlayerState* playerState) {$/;"	f
exec_player_main	player.c	/^PlayerExitCode exec_player_main(int argc, char** argv, GameState* gameState,$/;"	f
fmt_card	deck.c	/^char* fmt_card(char* str, Card card, bool dotSeparated) {$/;"	f
gameState	hubState.h	/^    GameState* gameState;$/;"	m	struct:HubState
gameState	playerState.h	/^    GameState* gameState;$/;"	m	struct:PlayerState
get_card_to_play	player.c	/^Card get_card_to_play(PlayerState* playerState) {$/;"	f
gs_card_played	gameState.c	/^void gs_card_played(GameState* gameState, int player, Card card) {$/;"	f
gs_destroy	gameState.c	/^void gs_destroy(GameState* gameState) {$/;"	f
gs_end_round	gameState.c	/^void gs_end_round(GameState* gameState) {$/;"	f
gs_fprint_cards	gameState.c	/^void gs_fprint_cards(GameState* gameState, FILE* file) {$/;"	f
gs_init	gameState.c	/^void gs_init(GameState* gameState, int numPlayers, int threshold) {$/;"	f
gs_new_round	gameState.c	/^void gs_new_round(GameState* gameState, int leadPlayer) {$/;"	f
hand	messages.h	/^    Deck hand; \/\/ for HAND$/;"	m	union:MessageData
hand	playerState.h	/^    Deck* hand; \/\/ malloc'd, but should not be manually free'd$/;"	m	struct:PlayerState
handSize	playerState.h	/^    int handSize;$/;"	m	struct:PlayerState
hs_card_played	hubState.c	/^void hs_card_played(HubState* hubState, int player, Card card) {$/;"	f
hs_deal_cards	hubState.c	/^void hs_deal_cards(HubState* hubState, Deck* deck) {$/;"	f
hs_destroy	hubState.c	/^void hs_destroy(HubState* hubState) {$/;"	f
hs_init	hubState.c	/^void hs_init(HubState* hubState, GameState* gameState) {$/;"	f
hs_set_pipe	hubState.c	/^void hs_set_pipe(HubState* hubState, int player, FILE* readFile,$/;"	f
hub_should_exit	hub.c	/^bool hub_should_exit(MessageStatus status, HubExitCode* outCode) {$/;"	f
ignore_sigpipe	util.c	/^void ignore_sigpipe(void) {$/;"	f
int_to_string	util.c	/^char* int_to_string(int number) {$/;"	f
is_card	deck.c	/^bool is_card(char* str) {$/;"	f
is_card_string	deck.c	/^bool is_card_string(char* str) {$/;"	f
is_null_card	deck.c	/^bool is_null_card(Card card) {$/;"	f
leadPlayer	gameState.h	/^    int leadPlayer;$/;"	m	struct:GameState
leadPlayer	messages.h	/^    int leadPlayer; \/\/ for NEWROUND$/;"	m	union:MessageData
leadSuit	gameState.h	/^    char leadSuit;$/;"	m	struct:GameState
main	hub.c	/^int main(int argc, char** argv) {$/;"	f
main	player.c	/^int main(int argc, char** argv) {$/;"	f
main	testDeck.c	/^int main(int argc, char** argv) {$/;"	f
main	testMessages.c	/^int main(int argc, char** argv) {$/;"	f
main	testUtil.c	/^int main(int argc, char** argv) {$/;"	f
make_deck	testDeck.c	/^Deck make_deck(void) {$/;"	f
msg_code	messages.c	/^char* msg_code(MessageType type) {$/;"	f
msg_decode_card	messages.c	/^bool msg_decode_card(char* payload, Card* outCard) {$/;"	f
msg_decode_hand	messages.c	/^bool msg_decode_hand(char* payload, Deck* outDeck) {$/;"	f
msg_decode_int	messages.c	/^bool msg_decode_int(char* payload, int* outInt) {$/;"	f
msg_decode_played	messages.c	/^bool msg_decode_played(char* payload, PlayedTuple* outTuple) {$/;"	f
msg_encode_card	messages.c	/^char* msg_encode_card(Card card) {$/;"	f
msg_encode_hand	messages.c	/^char* msg_encode_hand(Deck deck) {$/;"	f
msg_encode_int	messages.c	/^char* msg_encode_int(int value) {$/;"	f
msg_encode_played	messages.c	/^char* msg_encode_played(PlayedTuple tuple) {$/;"	f
msg_game_over	messages.c	/^Message msg_game_over(void) {$/;"	f
msg_hand	messages.c	/^Message msg_hand(Deck hand) {$/;"	f
msg_new_round	messages.c	/^Message msg_new_round(int leadPlayer) {$/;"	f
msg_payload_decode	messages.c	/^bool msg_payload_decode(MessageType type, char* payload, MessageData* data) {$/;"	f
msg_payload_encode	messages.c	/^char* msg_payload_encode(Message message) {$/;"	f
msg_play_card	messages.c	/^Message msg_play_card(Card card) {$/;"	f
msg_played_card	messages.c	/^Message msg_played_card(int player, Card card) {$/;"	f
msg_receive	messages.c	/^MessageStatus msg_receive(FILE* file, Message* outMessage) {$/;"	f
msg_send	messages.c	/^MessageStatus msg_send(FILE* file, Message message) {$/;"	f
new_sigaction	util.c	/^struct sigaction new_sigaction(void) {$/;"	f
noop_print	util.c	/^void noop_print(char* str) {$/;"	f
noop_printf	util.c	/^void noop_printf(char* fmt, ...) {$/;"	f
numCards	deck.h	/^    int numCards;$/;"	m	struct:Deck
numPlayers	gameState.h	/^    int numPlayers;$/;"	m	struct:GameState
one_player_turn	hub.c	/^HubExitCode one_player_turn(HubState* hubState, int currPlayer) {$/;"	f
parse_int	util.c	/^int parse_int(char* str) {$/;"	f
pipes	hubState.h	/^    PipePair* pipes;$/;"	m	struct:HubState
play_round	player.c	/^PlayerExitCode play_round(PlayerState* playerState, bool* outContinue) {$/;"	f
playedTuple	messages.h	/^    PlayedTuple playedTuple; \/\/ for PLAYED$/;"	m	union:MessageData
player	messages.h	/^    int player;$/;"	m	struct:PlayedTuple
playerHands	hubState.h	/^    Deck* playerHands;$/;"	m	struct:HubState
playerIndex	playerState.h	/^    int playerIndex;$/;"	m	struct:PlayerState
playerPoints	gameState.h	/^    int* playerPoints;$/;"	m	struct:GameState
player_args	hub.c	/^char** player_args(HubState* hubState, int playerNum, char* name) {$/;"	f
player_should_exit	player.c	/^bool player_should_exit(MessageStatus status, Message* message,$/;"	f
print_hub_message	exitCodes.c	/^void print_hub_message(HubExitCode code) {$/;"	f
print_player_message	exitCodes.c	/^void print_player_message(PlayerExitCode code) {$/;"	f
print_player_scores	hub.c	/^void print_player_scores(HubState* hubState) {$/;"	f
print_round_cards	hub.c	/^void print_round_cards(HubState* hubState) {$/;"	f
ps_destroy	playerState.c	/^void ps_destroy(PlayerState* playerState) {$/;"	f
ps_init	playerState.c	/^void ps_init(PlayerState* playerState, GameState* gameState, int playerIndex) {$/;"	f
ps_play	playerState.c	/^void ps_play(PlayerState* playerState, Card card) {$/;"	f
ps_set_hand	playerState.c	/^void ps_set_hand(PlayerState* playerState, Deck* hand) {$/;"	f
rank	deck.h	/^    int rank;$/;"	m	struct:Card
read	hubState.h	/^    FILE* read;$/;"	m	struct:PipePair
register_sighup	hub.c	/^void register_sighup(void) {$/;"	f
safe_read_line	util.c	/^bool safe_read_line(FILE* file, char** output) {$/;"	f
send_player_hands	hub.c	/^bool send_player_hands(HubState* hubState) {$/;"	f
sighup_handler	hub.c	/^void sighup_handler(int signal) {$/;"	f
start_player	hub.c	/^bool start_player(HubState* hubState, int playerNum, char* name) {$/;"	f
strategy_when_following	alice.c	/^int strategy_when_following(PlayerState* playerState) {$/;"	f
strategy_when_following	bob.c	/^int strategy_when_following(PlayerState* playerState) {$/;"	f
strategy_when_leading	alice.c	/^int strategy_when_leading(PlayerState* playerState) {$/;"	f
strategy_when_leading	bob.c	/^int strategy_when_leading(PlayerState* playerState) {$/;"	f
suit	deck.h	/^    char suit;$/;"	m	struct:Card
table	gameState.h	/^    Deck* table;$/;"	m	struct:GameState
threshold	gameState.h	/^    int threshold;$/;"	m	struct:GameState
to_card	deck.c	/^Card to_card(char* str) {$/;"	f
tokenise	util.c	/^int tokenise(char* line, char split, char** tokens, int maxTokens) {$/;"	f
type	messages.h	/^    MessageType type;$/;"	m	struct:Message
write	hubState.h	/^    FILE* write;$/;"	m	struct:PipePair
